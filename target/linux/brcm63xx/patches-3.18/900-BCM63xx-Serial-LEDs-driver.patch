diff -uprN a/arch/mips/bcm63xx/boards/board_common.c b/arch/mips/bcm63xx/boards/board_common.c
--- a/arch/mips/bcm63xx/boards/board_common.c	2015-03-01 14:14:02.652047930 +0100
+++ b/arch/mips/bcm63xx/boards/board_common.c	2015-03-02 01:03:52.250281527 +0100
@@ -123,6 +123,9 @@ void __init board_early_setup(const stru
 			val |= GPIO_MODE_6358_ENET1_MII_CLK_INV;
 	}
 
+	if (BCMCPU_IS_63268())
+		val |= BIT(0) | BIT(1);
+
 	bcm_gpio_writel(val, GPIO_MODE_REG);
 
 	/* Clear LEDCtrl register */
diff -uprN a/drivers/leds/Kconfig b/drivers/leds/Kconfig
--- a/drivers/leds/Kconfig	2015-03-01 14:14:00.912048009 +0100
+++ b/drivers/leds/Kconfig	2015-03-02 01:04:43.934922450 +0100
@@ -32,6 +32,20 @@ config LEDS_88PM860X
 	  This option enables support for on-chip LED drivers found on Marvell
 	  Semiconductor 88PM8606 PMIC.
 
+config LEDS_BCM6328
+	tristate "Serial LEDs support for BCM6328 chip"
+	depends on LEDS_CLASS
+	help
+	  This option enables support for serial LEDs connected to the BCM6328
+	  LED HW controller accessed via MMIO registers.
+
+config LEDS_BCM6358
+	tristate "Serial LEDs support for BCM6358 chip"
+	depends on LEDS_CLASS
+	help
+	  This option enables support for serial LEDs connected to the BCM6358
+	  LED HW controller accessed via MMIO registers.
+
 config LEDS_LM3530
 	tristate "LCD Backlight driver for LM3530"
 	depends on LEDS_CLASS
diff -uprN a/drivers/leds/leds-bcm6328.c b/drivers/leds/leds-bcm6328.c
--- a/drivers/leds/leds-bcm6328.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/leds/leds-bcm6328.c	2015-03-02 03:41:38.470530327 +0100
@@ -0,0 +1,150 @@
+/*
+ * Driver for BCM6328 memory-mapped Serial LEDs, based on leds-syscon.c
+ *
+ * Copyright 2015 Álvaro Fernández Rojas <noltari@gmail.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/stat.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+#include <linux/leds.h>
+
+#define LED_MODE_MASK	0x3
+#define LED_MODE_OFF	0x0
+#define LED_MODE_ON	0x3
+#define LED_SHIFT(X)	(((X) < 8) ? (32 + ((X) << 1)) : (((X) - 8) << 1))
+
+/**
+ * struct bcm6328_sled - state container for bcm6328 based serial leds
+ * @cdev: LED class device for this LED
+ * @dat: data register
+ * @pin: LED pin number
+ * @active_low: LED is active low
+ */
+struct bcm6328_sled {
+	struct led_classdev cdev;
+	void __iomem *dat;
+	u32 pin;
+	bool active_low;
+};
+
+static void bcm6328_sled_write(void __iomem *reg, unsigned long data)
+{
+	iowrite32be(data, reg);
+}
+
+static unsigned long bcm6328_sled_read(void __iomem *reg)
+{
+	return ioread32be(reg);
+}
+
+static void bcm6328_sled_value(struct bcm6328_sled *sled,
+	enum led_brightness value)
+{
+	u32 val;
+
+	val = bcm6328_sled_read(sled->dat);
+	val &= ~(LED_MODE_MASK << LED_SHIFT(sled->pin));
+	if((sled->active_low && value == LED_OFF) ||
+		(!sled->active_low && value != LED_OFF))
+		val |= (LED_MODE_OFF << LED_SHIFT(sled->pin));
+	else
+		val |= (LED_MODE_ON << LED_SHIFT(sled->pin));
+
+	bcm6328_sled_write(sled->dat, val);
+}
+
+static void bcm6328_sled_set(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	struct bcm6328_sled *sled =
+		container_of(led_cdev, struct bcm6328_sled, cdev);
+
+	bcm6328_sled_value(sled, value);
+}
+
+static int bcm6328_sleds_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+	struct resource *dat_r;
+	void __iomem *dat;
+
+	dat_r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dat");
+	if (!dat_r)
+		return -EINVAL;
+
+	dat = devm_ioremap_resource(dev, dat_r);
+	if (IS_ERR(dat))
+		return PTR_ERR(dat);
+
+	for_each_available_child_of_node(np, child) {
+		struct bcm6328_sled *sled;
+		const char *state;
+		int ret;
+
+		/* Only check for serial-leds */
+		if (of_property_match_string(child, "compatible",
+					     "serial-led") < 0)
+			continue;
+
+		sled = devm_kzalloc(dev, sizeof(*sled), GFP_KERNEL);
+		if (!sled)
+			return -ENOMEM;
+
+		sled->dat = dat;
+
+		if (of_property_read_u32(child, "pin", &sled->pin))
+			return -EINVAL;
+		if (of_get_property(child, "active-low", NULL))
+			sled->active_low = 1;
+		sled->cdev.name =
+			of_get_property(child, "label", NULL) ? : child->name;
+		sled->cdev.default_trigger =
+			of_get_property(child, "linux,default-trigger", NULL);
+
+		state = of_get_property(child, "default-state", NULL);
+		if (state) {
+			if (!strcmp(state, "on"))
+				bcm6328_sled_value(sled, LED_FULL);
+			else
+				bcm6328_sled_value(sled, LED_OFF);
+		}
+
+		sled->cdev.brightness_set = bcm6328_sled_set;
+
+		ret = led_classdev_register(dev, &sled->cdev);
+		if (ret < 0)
+			return ret;
+
+		dev_dbg(dev, "registered LED %s\n", sled->cdev.name);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id bcm6328_sleds_of_match[] = {
+	{ .compatible = "brcm,bcm6328-serial-leds", },
+	{},
+};
+#endif
+
+static struct platform_driver bcm6328_sleds_driver = {
+	.probe = bcm6328_sleds_probe,
+	.driver = {
+		.name = "bcm6328-sleds",
+		.of_match_table = of_match_ptr(bcm6328_sleds_of_match),
+	},
+};
+
+module_platform_driver(bcm6328_sleds_driver);
diff -uprN a/drivers/leds/leds-bcm6358.c b/drivers/leds/leds-bcm6358.c
--- a/drivers/leds/leds-bcm6358.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/leds/leds-bcm6358.c	2015-03-02 03:51:05.710094783 +0100
@@ -0,0 +1,167 @@
+/*
+ * Driver for BCM6358 memory-mapped Serial LEDs, based on leds-syscon.c
+ *
+ * Copyright 2015 Álvaro Fernández Rojas <noltari@gmail.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/stat.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+#include <linux/leds.h>
+
+#define SER_LED_BUSY		BIT(3)
+#define LEGACY_MAX_RETRIES	100
+
+/**
+ * struct bcm6358_sled - state container for bcm6358 based serial leds
+ * @cdev: LED class device for this LED
+ * @dat: data register
+ * @ctl: control register
+ * @pin: LED pin number
+ * @active_low: LED is active low
+ */
+struct bcm6358_sled {
+	struct led_classdev cdev;
+	void __iomem *dat;
+	void __iomem *ctl;
+	u32 pin;
+	bool active_low;
+};
+
+static void bcm6358_sled_write(void __iomem *reg, unsigned long data)
+{
+	iowrite32be(data, reg);
+}
+
+static unsigned long bcm6358_sled_read(void __iomem *reg)
+{
+	return ioread32be(reg);
+}
+
+static void bcm6358_sled_value(struct bcm6358_sled *sled,
+	enum led_brightness value)
+{
+	int i;
+
+	for(i = 0; i < LEGACY_MAX_RETRIES; i++)
+		if(!(bcm6358_sled_read(sled->ctl) & SER_LED_BUSY))
+			break;
+
+	if (i < LEGACY_MAX_RETRIES) {
+		u32 val;
+
+		val = bcm6358_sled_read(sled->dat);
+
+		if((sled->active_low && value == LED_OFF) ||
+			 (!sled->active_low && value != LED_OFF))
+			val &= ~BIT(sled->pin);
+		else
+			val |= BIT(sled->pin);
+
+		bcm6358_sled_write(sled->dat, val);
+	}
+}
+
+static void bcm6358_sled_set(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	struct bcm6358_sled *sled =
+		container_of(led_cdev, struct bcm6358_sled, cdev);
+
+	bcm6358_sled_value(sled, value);
+}
+
+static int bcm6358_sleds_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+	struct resource *dat_r, *ctl_r;
+	void __iomem *dat, *ctl;
+
+	dat_r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dat");
+	if (!dat_r)
+		return -EINVAL;
+
+	dat = devm_ioremap_resource(dev, dat_r);
+	if (IS_ERR(dat))
+		return PTR_ERR(dat);
+
+	ctl_r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ctl");
+	if (!ctl_r)
+		return -EINVAL;
+
+	ctl = devm_ioremap_resource(dev, ctl_r);
+	if (IS_ERR(ctl))
+		return PTR_ERR(ctl);
+
+	for_each_available_child_of_node(np, child) {
+		struct bcm6358_sled *sled;
+		const char *state;
+		int ret;
+
+		/* Only check for serial-leds */
+		if (of_property_match_string(child, "compatible",
+					     "serial-led") < 0)
+			continue;
+
+		sled = devm_kzalloc(dev, sizeof(*sled), GFP_KERNEL);
+		if (!sled)
+			return -ENOMEM;
+
+		sled->dat = dat;
+		sled->ctl = ctl;
+
+		if (of_property_read_u32(child, "pin", &sled->pin))
+			return -EINVAL;
+		if (of_get_property(child, "active-low", NULL))
+			sled->active_low = 1;
+		sled->cdev.name =
+			of_get_property(child, "label", NULL) ? : child->name;
+		sled->cdev.default_trigger =
+			of_get_property(child, "linux,default-trigger", NULL);
+
+		state = of_get_property(child, "default-state", NULL);
+		if (state) {
+			if (!strcmp(state, "on"))
+				bcm6358_sled_value(sled, LED_FULL);
+			else
+				bcm6358_sled_value(sled, LED_OFF);
+		}
+
+		sled->cdev.brightness_set = bcm6358_sled_set;
+
+		ret = led_classdev_register(dev, &sled->cdev);
+		if (ret < 0)
+			return ret;
+
+		dev_dbg(dev, "registered LED %s\n", sled->cdev.name);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id bcm6358_sleds_of_match[] = {
+	{ .compatible = "brcm,bcm6358-serial-leds", },
+	{},
+};
+#endif
+
+static struct platform_driver bcm6358_sleds_driver = {
+	.probe = bcm6358_sleds_probe,
+	.driver = {
+		.name = "bcm6358-sleds",
+		.of_match_table = of_match_ptr(bcm6358_sleds_of_match),
+	},
+};
+
+module_platform_driver(bcm6358_sleds_driver);
diff -uprN a/drivers/leds/Makefile b/drivers/leds/Makefile
--- a/drivers/leds/Makefile	2015-03-01 14:14:00.912048009 +0100
+++ b/drivers/leds/Makefile	2015-03-02 01:05:35.459671066 +0100
@@ -6,6 +6,8 @@ obj-$(CONFIG_LEDS_TRIGGERS)		+= led-trig
 
 # LED Platform Drivers
 obj-$(CONFIG_LEDS_88PM860X)		+= leds-88pm860x.o
+obj-$(CONFIG_LEDS_BCM6328)		+= leds-bcm6328.o
+obj-$(CONFIG_LEDS_BCM6358)		+= leds-bcm6358.o
 obj-$(CONFIG_LEDS_BD2802)		+= leds-bd2802.o
 obj-$(CONFIG_LEDS_LOCOMO)		+= leds-locomo.o
 obj-$(CONFIG_LEDS_LM3530)		+= leds-lm3530.o
