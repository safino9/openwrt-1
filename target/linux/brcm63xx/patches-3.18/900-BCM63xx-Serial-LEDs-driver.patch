diff -uprN a/arch/mips/bcm63xx/boards/board_common.c b/arch/mips/bcm63xx/boards/board_common.c
--- a/arch/mips/bcm63xx/boards/board_common.c	2015-03-01 14:14:02.652047930 +0100
+++ b/arch/mips/bcm63xx/boards/board_common.c	2015-03-01 14:15:43.366112981 +0100
@@ -123,6 +123,9 @@ void __init board_early_setup(const stru
 			val |= GPIO_MODE_6358_ENET1_MII_CLK_INV;
 	}
 
+	if (BCMCPU_IS_63268())
+		val |= BIT(0) | BIT(1);
+
 	bcm_gpio_writel(val, GPIO_MODE_REG);
 
 	/* Clear LEDCtrl register */
diff -uprN a/drivers/leds/Kconfig b/drivers/leds/Kconfig
--- a/drivers/leds/Kconfig	2015-03-01 14:14:00.912048009 +0100
+++ b/drivers/leds/Kconfig	2015-03-01 14:29:48.437598611 +0100
@@ -32,6 +32,13 @@ config LEDS_88PM860X
 	  This option enables support for on-chip LED drivers found on Marvell
 	  Semiconductor 88PM8606 PMIC.
 
+config LEDS_BCM63XX_SERIAL
+	tristate "Serial LEDs support for BCM63xx chip"
+	depends on LEDS_CLASS
+	help
+	  This option enables support for serial LEDs connected to the BCM63Xx
+	  LED HW controller accessed via MMIO registers.
+
 config LEDS_LM3530
 	tristate "LCD Backlight driver for LM3530"
 	depends on LEDS_CLASS
diff -uprN a/drivers/leds/leds-bcm63xx-serial.c b/drivers/leds/leds-bcm63xx-serial.c
--- a/drivers/leds/leds-bcm63xx-serial.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/leds/leds-bcm63xx-serial.c	2015-03-02 00:05:01.138942280 +0100
@@ -0,0 +1,199 @@
+/*
+ * Driver for BCM63XX memory-mapped Serial LEDs, based on leds-syscon.c
+ *
+ * Copyright 2015 Álvaro Fernández Rojas <noltari@gmail.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/stat.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+#include <linux/leds.h>
+
+#define SER_LED_BUSY	(1<<3)
+#define LEGACY_MAX_RETRIES	100
+
+#define LED_MODE_MASK	0x3
+#define LED_MODE_OFF	0x0
+#define LED_MODE_ON		0x3
+#define NUM_LED_SHIFT(X)	(((X) < 8) ? (32 + ((X) << 1)) : (((X) - 8) << 1))
+
+/**
+ * struct bcm63xx_sled - state container for bcm63xx based Serial LEDs
+ * @cdev: LED class device for this LED
+ * @dat: data register
+ * @ctl: control register
+ * @pin: LED pin number
+ */
+struct bcm63xx_sled {
+	struct led_classdev cdev;
+	void __iomem *dat;
+	void __iomem *ctl;
+	u32 pin;
+	bool legacy;
+	bool active_low;
+};
+
+static void bcm63xx_sled_write(void __iomem *reg, unsigned long data)
+{
+	iowrite32be(data, reg);
+}
+
+static unsigned long bcm63xx_sled_read(void __iomem *reg)
+{
+	return ioread32be(reg);
+}
+
+static void bcm63xx_sled_value(struct bcm63xx_sled *sled,
+	enum led_brightness value)
+{
+	u32 val;
+
+	if(sled->legacy) {
+		int i;
+
+		for(i = 0; i < LEGACY_MAX_RETRIES; i++) {
+			if(!(bcm63xx_sled_read(sled->ctl) & SER_LED_BUSY)) {
+				break;
+			}
+		}
+
+		if (i < LEGACY_MAX_RETRIES) {
+			val = bcm63xx_sled_read(sled->dat);
+
+			if((sled->active_low && value == LED_OFF) ||
+				(!sled->active_low && value != LED_OFF)) {
+				val &= ~BIT(sled->pin);
+			}
+			else {
+				val |= BIT(sled->pin);
+			}
+		}
+	}
+	else {
+		val = bcm63xx_sled_read(sled->dat);
+		val &= ~(LED_MODE_MASK << NUM_LED_SHIFT(sled->pin));
+
+		if((sled->active_low && value == LED_OFF) ||
+			(!sled->active_low && value != LED_OFF)) {
+			val |= (LED_MODE_OFF << NUM_LED_SHIFT(sled->pin));
+		}
+		else {
+			val |= (LED_MODE_ON << NUM_LED_SHIFT(sled->pin));
+		}
+	}
+
+	bcm63xx_sled_write(sled->dat, val);
+}
+
+static void bcm63xx_sled_set(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	struct bcm63xx_sled *sled =
+		container_of(led_cdev, struct bcm63xx_sled, cdev);
+
+	bcm63xx_sled_value(sled, value);
+}
+
+static int bcm63xx_sleds_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+	struct resource *dat_r, *ctl_r;
+	void __iomem *dat, *ctl;
+	bool legacy = false;
+
+	dat_r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dat");
+	if (!dat_r)
+		return -EINVAL;
+
+	dat = devm_ioremap_resource(dev, dat_r);
+	if (IS_ERR(dat))
+		return PTR_ERR(dat);
+
+	ctl_r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ctl");
+	if (ctl_r) {
+		legacy = true;
+
+		ctl = devm_ioremap_resource(dev, ctl_r);
+		if (IS_ERR(ctl))
+			return PTR_ERR(ctl);
+	}
+
+	for_each_available_child_of_node(np, child) {
+		struct bcm63xx_sled *sled;
+		const char *state;
+		int ret;
+
+		/* Only check for serial-leds */
+		if (of_property_match_string(child, "compatible",
+					     "serial-led") < 0)
+			continue;
+
+		sled = devm_kzalloc(dev, sizeof(*sled), GFP_KERNEL);
+		if (!sled)
+			return -ENOMEM;
+
+		sled->dat = dat;
+		sled->ctl = ctl;
+		sled->legacy = legacy;
+
+		if (of_property_read_u32(child, "pin", &sled->pin))
+			return -EINVAL;
+		if (of_get_property(child, "active_low", NULL))
+			sled->active_low = 1;
+		sled->cdev.name =
+			of_get_property(child, "label", NULL) ? : child->name;
+		sled->cdev.default_trigger =
+			of_get_property(child, "linux,default-trigger", NULL);
+
+		state = of_get_property(child, "default-state", "off");
+		if (state) {
+			if (!strcmp(state, "on")) {
+				bcm63xx_sled_value(sled, LED_FULL);
+			} else {
+				bcm63xx_sled_value(sled, LED_OFF);
+			}
+		}
+
+		sled->cdev.brightness_set = bcm63xx_sled_set;
+
+		ret = led_classdev_register(dev, &sled->cdev);
+		if (ret < 0)
+			return ret;
+
+		dev_info(dev, "registered LED %s\n", sled->cdev.name);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id bcm63xx_sleds_of_match[] = {
+	{ .compatible = "brcm,bcm6318-serial-leds", },
+	{ .compatible = "brcm,bcm63268-serial-leds", },
+	{ .compatible = "brcm,bcm6328-serial-leds", },
+	{ .compatible = "brcm,bcm6358-serial-leds", },
+	{ .compatible = "brcm,bcm6362-serial-leds", },
+	{ .compatible = "brcm,bcm6368-serial-leds", },
+	{},
+};
+#endif
+
+static struct platform_driver bcm63xx_sleds_driver = {
+	.probe = bcm63xx_sleds_probe,
+	.driver = {
+		.name = "bcm63xx-sleds",
+		.of_match_table = of_match_ptr(bcm63xx_sleds_of_match),
+	},
+};
+
+module_platform_driver(bcm63xx_sleds_driver);
diff -uprN a/drivers/leds/Makefile b/drivers/leds/Makefile
--- a/drivers/leds/Makefile	2015-03-01 14:14:00.912048009 +0100
+++ b/drivers/leds/Makefile	2015-03-01 14:30:23.260175573 +0100
@@ -6,6 +6,7 @@ obj-$(CONFIG_LEDS_TRIGGERS)		+= led-trig
 
 # LED Platform Drivers
 obj-$(CONFIG_LEDS_88PM860X)		+= leds-88pm860x.o
+obj-$(CONFIG_LEDS_BCM63XX_SERIAL)	+= leds-bcm63xx-serial.o
 obj-$(CONFIG_LEDS_BD2802)		+= leds-bd2802.o
 obj-$(CONFIG_LEDS_LOCOMO)		+= leds-locomo.o
 obj-$(CONFIG_LEDS_LM3530)		+= leds-lm3530.o
